# YACC

yacc的文法由一个使用BNF文法\(Backus­Naur form\)的变量描述。

E ­&gt; id  
像E\(表达式\)这样出现在左边的结构叫 非终结符\(nonterminal\)。像id\(标识符\)这样的结构叫终结符\(terminal,由lex返回的标记\),它 们只出现在右边。

不是从一个简单的非终结符开始,根据语法 生成一个表达式,而是把一个表达式逐步简化成一个非终结符。这叫做“自底向上”或者“移进­归约”分析法,这需要一个堆栈来保存信息。

匹配右式的标记被弹出堆 栈,而左式被压入堆栈。我们把所匹配的标记认为是一个句柄,而我们所做的就是把句柄向左式归 约。这个过程一直持续到把所有输入都压入堆栈中,而最终堆栈中只剩下最初的非终结符。

E ­&gt; E + E

是模糊不清的,因为我们既可以从左面又可以人右面递归。为了挽救这个危机,我们可以重写语法 规则,或者给yacc提供指示以明确操作符的优先顺序。

加法比 乘法拥有更高的优先级。这叫做“移进­归约”冲突\(shift­reduce conflict\)。

“归约­归约”冲突\(reduce­reduce conflict\)。当堆栈中存在id是,我们既可以归约 为T,也可以归约为E。

当存在冲突时,yacc将执行默认动作。当存在“移进­归约”冲突时,yacc将进行移进。当存在 “归约­归约”冲突时,yacc将执行列出的第一条规则。对于任何冲突,它都会显示警告信息。

...定义...

%%  
 ...规则...

%%

...子程序...  
 yacc的输入文件分成三段。“定义”段由一组标记声明和括在“%{”和“%}”之间的C代码组 成。BNF语法定义放在“规则”段中,而用户子程序添加在“子程序”段中

yacc在内部维护着两个堆栈;一个分析栈和一个内容栈。分析栈中保存着终结符和非终结符, 并且代表当前剖析状态。内容栈是一个YYSTYPE元素的数组,对于分析栈中的每一个元素都保存 着一个对应的值。

expr: expr '+' expr { $$ = $1 + $3; }

“$1”代表右式中的第一个成员,“$2”代表第二个,后面的以此类推。“$ $”表示缩小后的堆栈的顶部。在上面的动作中,把对应两个表达式的值相加,弹出内容栈中的三 个成员,然后把造得到的和压入堆栈中。

Lex有很多方便调试的工具。对于不同版本的lex其特征可能各不相同,因此你最好参考文档 以了解其细节。通过指定命令行参数“­d”,lex会在lex.yy.c中生成调试状态。通过设置变量yy \_flex\_debug可以打开或关闭flex\(GNU版本的lex\)中调试信息的输出。输出信息包括应用的规则 和相应的匹配文字。如果你在一起使用lex和yacc,那么需要在你的yacc输入文件中增加下面的代 码:

extern int yy\_flex\_debug; int main\(void\) {

yy\_flex\_debug = 1;

yyparse\(\); }

你也可能选择编写自己的调试代码,定义函数来显示各标志\(token\)对应的内容,以及联合体

yylval中每一个成员变量的的值。

