# lex&yacc

yacc ­d bas.y         \# 生成 y.tab.h, y.tab.c

lex bas.l            \# 生成 lex.yy.c

cc lex.yy.c y.tab.c ­o bas.exe   \# 编译/连接  
Yacc 读入 bas.y 中的语法描述而后生成一个剖析器,即 y.tab.c 中的函数 yyparse。bas.y 中包含  
的是一系列的标记声明。“­d”选项使

Yacc 生成标记声明并且把它们保存在 y.tab.c 中。Lex 读入 bas.l 中的正则表达式的说明,包含文件 y.tab.h,然后生成词汇解释器,即文件 lex.yy.c 中的函数 yylex。  
最终,这个解释器和剖析器被连接到一起,而组成一个可执行程序,bas.exe。我们从 main 函 数中调用 yyparse 来运行这个编译器。函数 yyparse 自动调用 yylex 以便获取每一个标志。

... 定义 ...

%%

... 规则 ...

%%

... 子程序 ...

lex 的输入文件分成三个段,段间用 %% 来分隔。

最短 的可用 lex 文件:

%%

输入字符将被一个字符一个字符直接输出。由于必须存在一个规则段,第一个 %% 总是要求存在 的。然而,如果我们不指定任何规则,默认动作就是匹配任意字符然后直接输出到输出文件。默认 的输入文件和输出文件分别是 stdin 和 stdout。

下面是效果完全相同的例子,显式表达了默认代码:

%%

/\* 匹配除换行外的任意字符 \*/

. ECHO;

/\* 匹配换行符 \*/

\n ECHO;

%%

int yywrap\(void\)

{  
return 1; }

int main\(void\)

{ yylex\(\);

return 0; }

上面规则段中指定了两个范式。每一个范式必须从第一列开始。紧跟后面的必须是空白区\(空格, TAB 或换行\),以及对应的任意动作。动作可以是单行的 C 代码,也可以是括在花括号中的多行 C 代码。任何不是从第一列开始的字符串都会被逐字拷贝进所生成的 C 文件中。我们可以利用这个特 殊行为在我们的 lex 文件中增加注释。在上例中有“.”和“\n”两个范式,对应的动作都是 ECHO。lex 预先字义了一些宏和变量。ECHO 就是一个用于直接输出范式所匹配的字符的宏。这也 是对任何未匹配字符的默认动作。通常 ECHO 是这样定义的:

\#define ECHO fwrite\(yytext, yyleng, 1, yyout\)

变量 yytext 是指向所匹配的字符串的指针\(以 NULL 结尾\),而 yyleng 是这个字符串的长度。变量yyout 是输出文件,默认状态下是 stdout。当 lex 读完输入文件之后就会调用函数 yywrap。如果返回 1 表示程序的工作已经完成了,否则返回 0。每一个 C 程序都要求一个 main 函数。在本例中我们只 是简单地调用 yylex,lex 扫描器的入口。有些 lex 实现的库中包含了 main 和 yywrap。这就是为什 么我们的第一个例子,最短的 lex 程序,能够正确运行。

![](/assets/importlex.png)

